<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>My Todo List</title>
  <link rel="stylesheet" href="style.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
</head>
<body class="tasks-page">
  <div id="notification-container"></div>

  <div class="tasks-container">
    <aside class="sidebar">
      <div class="sidebar-header">
        <h2>Welcome back, <span id="userName">USER</span>!</h2>
      </div>
      <div class="avatar-container">
        <div class="avatar" id="userAvatar">U</div>
      </div>
      <section class="stats-section">
        <div class="stat-card">
          <span class="stat-number" id="totalTasks">0</span>
          <span class="stat-label">Total tasks</span>
        </div>
        <div class="stat-card">
          <span class="stat-number" id="pendingTasks">0</span>
          <span class="stat-label">Pending</span>
        </div>
        <div class="stat-card">
          <span class="stat-number" id="completedTasks">0</span>
          <span class="stat-label">Completed</span>
        </div>
      </section>
      <div class="sidebar-buttons">
        <div id="theme-toggle" title="Toggle Theme">
          <i class="fas fa-moon"></i>
          <i class="fas fa-sun"></i>
        </div>
        <button id="profileBtn">Profile</button>
        <button id="logoutBtn">Logout</button>
      </div>
    </aside>

    <main class="main-content">
      <section class="task-input-section">
        <div class="input-field">
          <label for="taskInput">Task name</label>
          <input type="text" id="taskInput" placeholder="Add new task" />
        </div>
        <div class="input-field">
          <label for="startDateInput">Start date</label>
          <input type="date" id="startDateInput" />
        </div>
        <div class="input-field">
          <label for="prioritySelect">Priority level</label>
          <select id="prioritySelect">
            <option value="high">High</option>
            <option value="medium" selected>Medium</option>
            <option value="low">Low</option>
          </select>
        </div>
        <div class="input-field">
          <label for="dueDateInput">Due date</label>
          <input type="date" id="dueDateInput" />
        </div>
        <div class="input-field">
          <label for="statusSelect">Status</label>
          <select id="statusSelect">
            <option value="pending">Pending</option>
            <option value="in-progress">In Progress</option>
            <option value="completed">Completed</option>
          </select>
        </div>
        <div class="input-field description-field">
          <label for="taskDescriptionInput">Description</label>
          <textarea id="taskDescriptionInput" placeholder="Enter a description..."></textarea>
        </div>
        <button id="addTaskBtn">Add task</button>
      </section>

      <section class="tasks-list-section">
        <div class="list-header">
          <h2>Widgets</h2>
          <div class="filter-field">
            <label for="filterPriority">Filter by Priority:</label>
            <select id="filterPriority">
              <option value="all">All priorities</option>
              <option value="high">High</option>
              <option value="medium">Medium</option>
              <option value="low">Low</option>
            </select>
          </div>
        </div>
        <div id="taskList">
          <!-- Tasks will be dynamically inserted here -->
        </div>
      </section>
    </main>
  </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const token = localStorage.getItem('token');
    if (!token) {
        window.location.href = 'login.html';
        return;
    }

    // --- DOM Elements ---
    const userNameSpan = document.getElementById('userName');
    const userAvatar = document.getElementById('userAvatar');
    const addTaskBtn = document.getElementById('addTaskBtn');
    const taskInput = document.getElementById('taskInput');
    const taskDescriptionInput = document.getElementById('taskDescriptionInput');
    const prioritySelect = document.getElementById('prioritySelect');
    const statusSelect = document.getElementById('statusSelect');
    const startDateInput = document.getElementById('startDateInput');
    const dueDateInput = document.getElementById('dueDateInput');
    const filterPriority = document.getElementById('filterPriority');
    const taskList = document.getElementById('taskList');
    const logoutBtn = document.getElementById('logoutBtn');
    const profileBtn = document.getElementById('profileBtn');
    const notificationContainer = document.getElementById('notification-container');
    const themeToggle = document.getElementById('theme-toggle');
    const body = document.body;

    // --- App State ---
    let allTasks = [];
    let editingTaskId = null;

    // --- Helper Functions ---
    const showNotification = (message, isError = false) => {
        const notification = document.createElement('div');
        notification.className = `notification ${isError ? 'error' : 'success'}`;
        notification.textContent = message;
        notificationContainer.appendChild(notification);

        setTimeout(() => notification.classList.add('show'), 10);

        setTimeout(() => {
            notification.classList.remove('show');
            setTimeout(() => notification.remove(), 500);
        }, 3000);
    };

    const formatDate = (dateString) => {
        if (!dateString) return 'N/A';
        const options = { month: 'short', day: 'numeric', year: 'numeric' };
        return new Date(dateString).toLocaleDateString('en-US', options);
    };

    const fetchUser = async () => {
        const userName = localStorage.getItem('userName') || 'User';
        userNameSpan.textContent = userName;
        userAvatar.textContent = userName.charAt(0).toUpperCase();
    };
    
    const fetchTasks = async () => {
        try {
            const response = await fetch('/tasks', {
                headers: { 'Authorization': `Bearer ${token}` }
            });
            if (!response.ok) throw new Error('Failed to fetch tasks');
            allTasks = await response.json();
            renderTasks();
            updateStats();
        } catch (error) {
            showNotification('Could not load tasks.', true);
        }
    };

    const renderTasks = () => {
        const filterValue = filterPriority.value;
        const filteredTasks = allTasks.filter(task => filterValue === 'all' || task.priority === filterValue);
        
        taskList.innerHTML = '';
        if (filteredTasks.length === 0) {
            taskList.innerHTML = '<p style="text-align: center; padding: 20px;">No tasks found.</p>';
            return;
        }

        filteredTasks.forEach(task => {
            const taskElement = document.createElement('div');
            taskElement.className = `task ${task.priority.toLowerCase()} ${task.status}`;
            taskElement.dataset.id = task._id;
            
            taskElement.innerHTML = `
                <div class="task-content">
                    <h4>${task.name}</h4>
                    <p class="description">${task.description || 'No description.'}</p>
                    <p class="status">Status: <span>${task.status}</span></p>
                    <p class="start-date">Start date: <span>${formatDate(task.startDate)}</span></p>
                    <p class="due-date">Due date: <span>${formatDate(task.dueDate)}</span></p>
                </div>
                <div class="task-actions">
                    <button class="done-btn">Done</button>
                    <button class="edit-btn">Edit</button>
                    <button class="delete-btn">Delete</button>
                </div>
            `;
            taskList.appendChild(taskElement);
        });
    };

    const updateStats = () => {
        document.getElementById('totalTasks').textContent = allTasks.length;
        document.getElementById('pendingTasks').textContent = allTasks.filter(t => t.status !== 'completed').length;
        document.getElementById('completedTasks').textContent = allTasks.filter(t => t.status === 'completed').length;
    };

    const handleAddTask = async () => {
        const name = taskInput.value.trim();
        if (!name) {
            showNotification('Task name cannot be empty.', true);
            return;
        }

        let taskData = { 
            name, 
            description: taskDescriptionInput.value.trim(), 
            priority: prioritySelect.value, 
            startDate: startDateInput.value, 
            dueDate: dueDateInput.value, 
            status: statusSelect.value 
        };
        let url = '/tasks';
        let method = 'POST';

        if (editingTaskId) {
            url = `/tasks/${editingTaskId}`;
            method = 'PUT';
        }

        try {
            const response = await fetch(url, {
                method,
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
                body: JSON.stringify(taskData)
            });
            if (!response.ok) {
                const errorResult = await response.json();
                throw new Error(errorResult.message || 'Failed to save task');
            }
            
            taskInput.value = '';
            taskDescriptionInput.value = '';
            prioritySelect.value = 'medium';
            statusSelect.value = 'pending';
            startDateInput.value = '';
            dueDateInput.value = '';
            addTaskBtn.textContent = 'Add task';
            editingTaskId = null;
            
            showNotification(editingTaskId ? 'Task updated successfully!' : 'Task added successfully!');
            await fetchTasks();
        } catch (error) {
            showNotification(`Could not save task: ${error.message}`, true);
        }
    };
    
    const handleTaskListClick = async (e) => {
        const taskElement = e.target.closest('.task');
        if (!taskElement) return;

        const id = taskElement.dataset.id;
        const task = allTasks.find(t => t._id === id);
        if (!task) return;

        const headers = { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` };

        if (e.target.classList.contains('delete-btn')) {
            try {
                const response = await fetch(`/tasks/${id}`, { method: 'DELETE', headers });
                if (!response.ok) throw new Error('Failed to delete');
                await fetchTasks();
                showNotification('Task deleted successfully.');
            } catch (error) {
                showNotification('Could not delete task.', true);
            }
        } else if (e.target.classList.contains('edit-btn')) {
            taskInput.value = task.name;
            taskDescriptionInput.value = task.description;
            prioritySelect.value = task.priority;
            statusSelect.value = task.status;
            startDateInput.value = task.startDate ? task.startDate.split('T')[0] : '';
            dueDateInput.value = task.dueDate ? task.dueDate.split('T')[0] : '';
            editingTaskId = id;
            addTaskBtn.textContent = 'Update Task';
            taskInput.focus();
        } else if (e.target.classList.contains('done-btn')) {
            try {
                const response = await fetch(`/tasks/${id}`, {
                    method: 'PUT',
                    headers,
                    body: JSON.stringify({ status: 'completed' })
                });

                if (!response.ok) {
                    throw new Error('Failed to update task');
                }
                await fetchTasks();
                showNotification('Task marked as completed.');
            } catch (error) {
                showNotification('Could not update task status.', true);
            }
        }
    };

    const applyTheme = (theme) => {
        if (theme === 'dark') {
            body.classList.add('dark-mode');
        } else {
            body.classList.remove('dark-mode');
        }
    };

    // --- Event Listeners ---
    addTaskBtn.addEventListener('click', handleAddTask);
    taskList.addEventListener('click', handleTaskListClick);
    filterPriority.addEventListener('change', renderTasks);
    logoutBtn.addEventListener('click', () => {
        localStorage.removeItem('token');
        localStorage.removeItem('userName');
        window.location.href = 'login.html';
    });
    profileBtn.addEventListener('click', () => {
        window.location.href = 'profile.html';
    });
    themeToggle.addEventListener('click', () => {
        const isDarkMode = body.classList.contains('dark-mode');
        const newTheme = isDarkMode ? 'light' : 'dark';
        localStorage.setItem('theme', newTheme);
        applyTheme(newTheme);
    });

    // --- Initial Load ---
    const savedTheme = localStorage.getItem('theme') || 'light';
    applyTheme(savedTheme);
    fetchUser();
    fetchTasks();
});
</script>
</body>
</html>
